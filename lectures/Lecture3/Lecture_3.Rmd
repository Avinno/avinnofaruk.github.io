---
width: 1440
height: 900
output: 
  revealjs::revealjs_presentation:
    css: ../header.css
    theme: default
    reveal_options:
      controls: false
      slideNumber: false
      previewLinks: true
      progress: true
      logo: true
    center: false
    highlight: default
    transition: none
    mathjax: default
    slide_level: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(tidyquant)
library(knitr)
library(kableExtra)
```

<style type="text/css">
  .reveal p {
    text-align: left;
  }
  .reveal ul {
    display: block;
  }
  .reveal ol {
    display: block;
  }
  td {
   font-size: 16px;
  }
</style>

<script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? '../pdf.css' : '../paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
</script>

<section class=center>
## Lecture 3: Portfolio Optimization
</section>

---

# Risk Aversion

* We now know from our historical data that risky asset returns tend to beat safe asset returns
    - "In Expectation"
* Since there's a positive "premium" for risk, how much risk are you willing to bear?
    - This depends on risk tolerance


---

# Preview of our goal

* Solve two problems:
    1. How should we distribute our wealth between a risky portfolio of assets and the risk‐free asset based on our risk aversion?
    2. What portfolio of risky assets should we hold?
* With many risky assets, there is an optimal portfolio of these assets that all investors prefer
    - Lectures on active management will address departures from this optimal risky portfolio


---

# Risk, Risk Aversion and Gambles

* Consider the following gamble (where you pay me a dollar):
    - With probability 0.5, I give you 2 dollars
    - With probability 0.5, I give you 50 cents
* What are the expected returns? Variance?
    $$
    \begin{aligned}
    E(r_{\text{gamble}}) &= 0.5 \times (2-1) + 0.5 \times (0.5 - 1) = 0.25\\
    \sigma^{2}(r_{\text{gamble}}) &=  0.5 \times (1 - 0.25)^2 + 0.5 \times (-0.5-0.25)^2 = 0.5625 \\
    \sigma(r_{\text{gamble}})  &= \sqrt{ 0.5625 } = 0.75
    \end{aligned}
    $$
* Would you take it? What if you paid me 1.25?
* At what cost would you become unwilling to take this deal? 
    - Known as the "certainty equivalence"
    
---

# Risk, Risk Aversion and Gambles

* Ok, now consider another gamble (where you pay me a dollar):
    - With probability 0.4, I give you 3 dollars
    - With probability 0.2, I give you 1  dollar
    - With probability 0.4, I give you 25 cents
* What are the expected returns? Variance?
    $$
    \begin{aligned}
    E(r_{\text{gamble}}) &= ?\\
    \sigma^{2}(r_{\text{gamble}}) &= ?\\
    \sigma(r_{\text{gamble}})  &= ?
    \end{aligned}
    $$

---

# Preferences

* Let's assume a simple model of preferences over returns and risk.

$$ 
U(r) = E(r) - \frac{1}{2} \times A \times \sigma^{2}(r)
$$
    * $A>0$ implies risk aversion
    * $A = 0$ implies risk neutrality
    * $A < 0$ implies risk seeking
    
* U(r) provides an **ordering** over investments, given their returns and risks

* This particular function can be derived under a number of different assumptions and is widely used by practitioners and academics

---

# Preferences

```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
library(purrr)

calc_e_r  <- function(sd, U_bar, A) {
  e_r <- U_bar + A * 0.5 * sd^2
  return(as.data.frame(e_r))
}


sd <- seq(0,1,.1)
U <- seq(0.1, 0.3,0.1)
plot_results <- as.data.frame(expand.grid(sd, U)) %>% rename(sd = Var1, U = Var2)

e_r <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 1))
plot_results <- cbind(plot_results, e_r)


```


$$ 
U(r) = E(r) - \frac{1}{2} \times A \times \sigma^{2}(r)
$$

For $A = 1$:

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE}

ggplot(data = plot_results,  aes(y = e_r, x = sd, color = as.factor(U))) +
  geom_line() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle")) + 
  scale_color_viridis_d("Fixed Utility Level") +
  xlab(bquote("Standard Deviation of Asset" ~ sigma))  +
  ylim(0, 0.8) +
  ggtitle("Expected return for given U across asset standard deviation") +
  annotate(geom="text", x = 0.1, y = 0.6, label = "A = 1")
```


---

# Preferences


```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
plot_results <- as.data.frame(expand.grid(sd, U)) %>% rename(sd = Var1, U = Var2)

e_r <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 0.5))
plot_results <- cbind(plot_results, e_r)


```


$$ 
U(r) = E(r) - \frac{1}{2} \times A \times \sigma^{2}(r)
$$

For $A = 0.5$:

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE}

ggplot(data = plot_results,  aes(y = e_r, x = sd, color = as.factor(U))) +
  geom_line() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle")) + 
  scale_color_viridis_d("Fixed Utility Level") +
  xlab(bquote("Standard Deviation of Asset" ~ sigma))  +
  ylim(0, 0.8) +
  ggtitle("Expected return for given U across asset standard deviation") +
  annotate(geom="text", x = 0.1, y = 0.6, label = "A = 0.5")
```

---

# Preferences



```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
plot_results <- as.data.frame(expand.grid(sd, U)) %>% rename(sd = Var1, U = Var2)

e_r <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 0))
plot_results <- cbind(plot_results, e_r)


```


$$ 
U(r) = E(r) - \frac{1}{2} \times A \times \sigma^{2}(r)
$$

For $A = 0.0$:

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE}

ggplot(data = plot_results,  aes(y = e_r, x = sd, color = as.factor(U))) +
  geom_line() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle")) + 
  scale_color_viridis_d("Fixed Utility Level") +
  xlab(bquote("Standard Deviation of Asset" ~ sigma))  +
  ylim(0, 0.8) +
  ggtitle("Expected return for given U across asset standard deviation") +
  annotate(geom="text", x = 0.1, y = 0.6, label = "A = 0.0")
```


---

# Preferences

```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}
plot_results <- as.data.frame(expand.grid(sd, U)) %>% rename(sd = Var1, U = Var2)

e_r <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 1))
e_r2 <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 0.5))

plot_results <- cbind(plot_results, e_r, e_r2)
colnames(plot_results) <- c("sd", "U", "er.1", "er.5")

plot_results <- plot_results %>% 
  gather(key = A, value = e_r, -sd, -U) %>%
  separate(A, c("test", "A") ) %>% 
  select(-test) %>%
  mutate(A = case_when(A > 1 ~ 0.5,
                         TRUE ~ 1))




```


$$ 
U(r) = E(r) - \frac{1}{2} \times A \times \sigma^{2}(r)
$$


```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning = FALSE}

ggplot(data = plot_results,  aes(y = e_r, x = sd, color = as.factor(U))) +
  geom_line(aes(linetype = as.factor(A))) +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle")) + 
  scale_color_viridis_d("Fixed Utility Level") +
  scale_linetype_discrete("Risk Aversion") +
  xlab(bquote("Standard Deviation of Asset" ~ sigma))  +
  ylim(0, 0.8) +
  ggtitle("Expected return for given U across asset standard deviation") 
```

---

# Allocating between 1 risky and 1 riskless asset

* Back to our first example: 
    - The risky asset's return is $r_{p}=0.25$, $\sigma = 0.75$ 
    - and there is a riskless asset's with return $r_{f} = 0.03$,  $\sigma = 0$

* Utility ($U(r)$) across assets:

| Risk Aversion  | A=0.04 | A=0.5 | A=0.78 | A=1 |
|----------------|--------|-------|--------|-----|
| Risk Free      | 0.03   |  0.03 | 0.03   | 0.03|
| Risky          | 0.24   |  0.11 | 0.03   |-0.03|

* For risk aversion of 0.5, do you prefer $r_{f}$ or investment $r_{p}$? 
* Suppose the constant of risk aversion is 0.78?

* Now what about if you can choose to invest in both assets, but with different weights?

* What weight ($w$) should you allocate to the risky asset?

---

# Expected returns from a blended portfolio

* Expected returns on a portfolio combining the risky $(p)$ and risk-free asset asset are:

$$ 
\begin{aligned}
E(r_{\text{blended}}) & = E\big(wr_{p} + (1-w)r_{f}\big)\\
                      & = wE(r_{p}) + (1-w)E(r_{f})\\
                      & = r_{f} + wE(r_{p}-r_{f})
\end{aligned}
$$

* Note, expected returns on the complete portfolio are equal to two parts:
    1. the risk free return ($r_{f}$)
    2. the compensation for exposure to the risk in the risky asset ($E(r_{p} - r_{f})$)
        + Sometimes referred to as the "premium"
        
        
---

# Return variance from a blended portfolio

* The variance of returns from the blended portfolio is:

$$
\begin{aligned}
\sigma^{2}(r_{\text{blended}}) &= \text{Var}\big(wr_{p} + (1-w)r_{f}\big)\\
                               &= w^{2}\sigma^{2}(r_{p}) + (1-w)^{2}\sigma^{2}(r_{f}) + 2w(1-w)\sigma(r_{p}, r_{f})\\
                               &= w^{2}\sigma^{2}(r_{p})\\
                               \sigma(r_{\text{blended}})&= w \sigma(r_{p})
\end{aligned}
$$

* When we combine these two equations, we get the "**capital allocation line**"

$$
E(r_{\text{blended}}) = r_{f} + \sigma(r_{\text{blended}})\frac{E(r_{p} - r_{f})}{\sigma_{p}}
$$

---

# Capital Allocation Line

* When we combined these two equations, we get the "**capital allocation line**"

$$
E(r_{\text{blended}}) = r_{f} + \sigma(r_{\text{blended}})\frac{E(r_{p} - r_{f})}{\sigma_{p}}
$$


* In our simple example, 

$$
E(r_{\text{blended}}) = r_{f} + \sigma(r_{\text{blended}})\frac{E(r_{p} - r_{f})}{\sigma_{p}} = 0.03 + \sigma(r_{\text{blended}}) \frac{0.22}{0.75}
$$

* The capital allocation line shows all risk‐return combinations available based on choice of w.

* The slope of the capital allocation line (the Sharpe Ratio) prices the risk-return tradeoff
* In our example, the Sharpe Ratio is 0.29 (0.22/0.75)

---

#  Capital Allocation Line

$$
E(r_{\text{blended}}) = r_{f} + \sigma(r_{\text{blended}})\frac{E(r_{p} - r_{f})}{\sigma_{p}}
$$

```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}

calc_CAL  <- function(r_f, w, sharpe_ratio, sigma_p) {
  e_r <- r_f + w*sigma_p * (sharpe_ratio)
  return(as.data.frame(e_r))
}

r_f <- 0.03
r_p <- 0.25
sigma_p <- 0.75
sigma_f <- 0
w  <- seq(0,1.4,.1)

e_r <-  map_dfr(w, function(x) calc_CAL(r_f, x, (r_p - r_f)/sigma_p , sigma_p))
plot_results <- cbind(w, e_r) %>% mutate( sd= sigma_p*w)


```



```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE}

ggplot(data = plot_results,  aes(y = e_r, x = sd)) +
  geom_line() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Blended Portfolio"))  +
  ylim(0, 0.5) +
  ggtitle("Expected return across different weights") +
  annotate(geom="point", x = 0.75, y = 0.25, size = 3) + 
  annotate(geom="text", x = 0.83, y = 0.25, label = "w=1",  size = 6) +
  annotate(geom="point", x = 0, y = 0.03, size = 3) + 
  annotate(geom="text", x = 0.08, y = 0.03, label = "w=0",  size = 6)
```

---

# Choosing w

* Which risk return combination do we want?
* Find point where utility cannot move any further to the northwest, but still touches the CAL

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning = FALSE}

A <- 1
w_star <- (r_p - r_f)/(A*sigma_p^2)
U <- r_f + w_star* (r_p - r_f) - 0.5 * A * w_star^2 * sigma_p^2
U2 <- c(U - .1, U, U + 0.1)
sd <- seq(0,1,.1)
plot_results <- as.data.frame(expand.grid(sd, U2)) %>% rename(sd = Var1, U = Var2)

e_r <-  map2_dfr(plot_results$sd, plot_results$U, function(x,y) calc_e_r(x, y, 1))

plot_results <- cbind(plot_results, e_r)
colnames(plot_results) <- c("sd", "U", "er.1")

plot_results <- plot_results %>% 
  gather(key = A, value = e_r, -sd, -U) %>%
  separate(A, c("test", "A") ) %>% 
  select(-test)

calc_CAL  <- function(r_f, w, sharpe_ratio, sigma_p) {
  e_r <- r_f + w*sigma_p * (sharpe_ratio)
  return(as.data.frame(e_r))
}


w  <- seq(0,1.4,.1)

e_r <-  map_dfr(w, function(x) calc_CAL(.03, x, 0.29, 0.75))
plot_results2 <- cbind(w, e_r) %>% mutate( sd= 0.75*w)

ggplot() +
  geom_line(data = plot_results2,  aes(y = e_r, x = sd)) +
  geom_path(data = plot_results,  aes(y = e_r, x = sd, color=as.factor(U))) +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Blended Portfolio"))  +
  ylim(0, 0.5) +
  ggtitle("Expected return across different weights") +
  annotate(geom="point", x = 0.75, y = 0.25, size = 3) + 
  annotate(geom="text", x = 0.83, y = 0.25, label = "w=1",  size = 6) +
  annotate(geom="point", x = 0, y = 0.03, size = 3) + 
  annotate(geom="text", x = 0.08, y = 0.03, label = "w=0",  size = 6) +
  annotate(geom="point", x = w_star*sigma_p, y = r_f + w_star* (r_p - r_f), size = 3) + 
  annotate(geom="text",  x = w_star*sigma_p + 0.08, y = r_f + w_star* (r_p - r_f), label = "w=w*",  size = 6) +
  scale_color_viridis_d(guide=FALSE)
```

---

# Choosing w

* We can solve this problem more formally as

$$
\max_{w} U(r_{blend}) = r_{f} + w E(r_{p} - r_{f}) - \frac{1}{2} A w^{2} \sigma^{2}(r_{p})
$$

* This is solved by finding the value of w that sets the derivative equal to zero:

$$
w^{*} = \frac{E(r_{p} - r_{f})}{A\sigma^{2}(r_{p})}
$$

---

# Choosing w

* Back to our example:

| A | $w^{*}$ | $E(r_{\text{blended}})$ | $\sigma_{\text{blended}}$ |
|---|--------|-----------------------|-------------------------|
| 0.25 | 1.56 | 0.37| 1.17|
| 0.5 | 0.78 | 0.2 | 0.51 |
| 0.78| 0.49 | 0.14|0.37 |
|1 | 0.39 | 0.12 | 0.29|

* What is the meaning of 1.56 in this table? Can you ever get a negative w?
* How are the standard deviations and expected returns for these optimal portfolios computed?

---

# Two Risky Assets

* Now suppose instead of choosing a mix between a risky and a risk‐free asset, we have two risky assets (but no risk free asset).

* The expected return for the portfolio of risky assets A and B is
$$
E(r_{p}) = w_{a}E(r_{a}) + (1-w)E(r_{b})
$$
where $w_{a}$ is the weight on stock A.

* The variance and standard deviation of the portfolio are:

$$
\begin{aligned}
\sigma^{2}(r_{\text{p}}) &= \text{Var}\big(w_{a}r_{a} + (1-w_{a})r_{b}\big)\\
                               &= w_{a}^{2}\sigma^{2}(r_{a}) + (1-w)^{2}\sigma^{2}(r_{b}) + 2w_{a}(1-w_{a})\sigma(r_{a}, r_{b})\\
                               &= w_{a}^{2}\sigma^{2}(r_{a}) + (1-w)^{2}\sigma^{2}(r_{b}) + 2w_{a}(1-w_{a})\rho_{a,b}\sigma(r_{a})\sigma(r_{b})
\end{aligned}
$$

---

# Two Risky Assets

* Now suppose assets A and B are characterized as follows:

| Asset | $E(r)$ | $\sigma(r)$ | 
|:-------:|:--------:|:-------------:|
|  A | 0.25 | 0.75 |
| B  | 0.1 | 0.25 |

* Consider the frontier of returns/standard deviations available by allocating different amounts to the two assets (i.e. varying w)
* Notice the variance calculation now includes the correlation between A and B
    - Sheet MVfrontier.xls plots the frontier for different correlations 

---

# 2 Risky Assets (correlation $\rho$ =1)

| Asset | $E(r)$ | $\sigma(r)$ | 
|:-------:|:--------:|:-------------:|
|  A | 0.25 | 0.75 |
| B  | 0.1 | 0.25 |

$$\rho_{a,b} = 1$$
```{r, include=FALSE, cache=TRUE, echo=FALSE, message=FALSE}

calc_CAL_ab  <- function(r_a, r_b, sigma_a, sigma_b, rho, w) {
  e_r <- w*r_a + (1-w)*r_b
  sigma_r <-  sqrt(w^2 *sigma_a^2 + (1-w)^2 *sigma_b^2 + 2*w*(1-w)*rho*sigma_a*sigma_b)
  return(as.data.frame(cbind(e_r, sigma_r)))
}


w  <- seq(-3,2.5,.01)


```

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}
r_a <- 0.25
r_b <- 0.1
sigma_a <- 0.75
sigma_b <- 0.25
rho <- 1

output <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
output2 <- cbind(output, rbind(tibble(w=w))) %>%
  arrange(w)

ggplot(data = output2,  aes(y = e_r, x = sigma_r)) +
  geom_path() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Blended Portfolio"))  +
  ylim(-0.4, 0.35) +
  xlim(0,1.5) +
  ggtitle(bquote("Expected return across different weights" ~ rho ~ "=" ~ .(rho))) +
  annotate(geom="point", x = 0.75, y = 0.25, size = 3) + 
  annotate(geom="text", x = 0.83, y = 0.25, label = "w=1",  size = 6) +
  annotate(geom="point", x = 0.25, y = 0.1, size = 3) + 
  annotate(geom="text", x = 0.33, y = 0.1, label = "w=0",  size = 6)
```

---

# 2 Risky Assets (correlation $\rho$ =-1)

| Asset | $E(r)$ | $\sigma(r)$ | 
|:-------:|:--------:|:-------------:|
|  A | 0.25 | 0.75 |
| B  | 0.1 | 0.25 |

$$\rho_{a,b} = -1$$


```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}
r_a <- 0.25
r_b <- 0.1
sigma_a <- 0.75
sigma_b <- 0.25
rho <- -1

output <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
output2 <- cbind(output, rbind(tibble(w=w))) %>%
  arrange(w)

ggplot(data = output2,  aes(y = e_r, x = sigma_r)) +
  geom_path() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Blended Portfolio"))  +
  ylim(-0.4, 0.35) +
  xlim(0,1.5) +
  ggtitle(bquote("Expected return across different weights" ~ rho ~ "=" ~ .(rho))) +
  annotate(geom="point", x = 0.75, y = 0.25, size = 3) + 
  annotate(geom="text", x = 0.83, y = 0.25, label = "w=1",  size = 6) +
  annotate(geom="point", x = 0.25, y = 0.1, size = 3) + 
  annotate(geom="text", x = 0.33, y = 0.1, label = "w=0",  size = 6)
```

---

# 2 Risky Assets (correlation $\rho$ =0)

| Asset | $E(r)$ | $\sigma(r)$ | 
|:-------:|:--------:|:-------------:|
|  A | 0.25 | 0.75 |
| B  | 0.1 | 0.25 |

$$\rho_{a,b} = 0$$

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}
r_a <- 0.25
r_b <- 0.1
sigma_a <- 0.75
sigma_b <- 0.25
rho <- 0

output <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
output2 <- cbind(output, rbind(tibble(w=w))) %>%
  arrange(w)

ggplot(data = output2,  aes(y = e_r, x = sigma_r)) +
  geom_path() +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Blended Portfolio"))  +
  ylim(-0.4, 0.35) +
  xlim(0,1.5) +
  ggtitle(bquote("Expected return across different weights" ~ rho ~ "=" ~ .(rho))) +
  annotate(geom="point", x = 0.75, y = 0.25, size = 3) + 
  annotate(geom="text", x = 0.83, y = 0.25, label = "w=1",  size = 6) +
  annotate(geom="point", x = 0.25, y = 0.1, size = 3) + 
  annotate(geom="text", x = 0.33, y = 0.1, label = "w=0",  size = 6)
```

---

# Two risky assets

* Given the available risk return trade‐offs, which portfolio provides the highest utility level for a given investor?
    - Depends on their risk aversion (A)!
* More risk averse investors will choose a relatively safer portfolio
    - This changes once you have a riskless asset to invest in
    
---

# Two Risky Assets 

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}
## Capital Allocation Lines
r_a <- 0.25
r_b <- 0.1
sigma_a <- 0.75
sigma_b <- 0.25
rho <- 0
A1 <- 0.5
A2 <- 2

w_star1 <- (r_a - r_b) / (A1* (sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) +
  ((sigma_b^2 - rho*sigma_a*sigma_b)/(sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) 
w_star2 <- (r_a - r_b) / (A2* (sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) +
  ((sigma_b^2 - rho*sigma_a*sigma_b)/(sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) 

opt_portfolio1 <- calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, w_star1)
opt_portfolio2 <- calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, w_star2)
U_star1 <- opt_portfolio1$e_r - (A1/2)*opt_portfolio1$sigma_r^2
U_star2 <- opt_portfolio2$e_r - (A2/2)*opt_portfolio2$sigma_r^2

output <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
capital_lines <- cbind(output, rbind(tibble(w=w))) %>%
  arrange(w)

## Utility Curves
sd <- seq(0,1.5, 0.01)

plot_results1 <- as.data.frame(expand.grid(sd, U_star1)) %>% rename(sd = Var1, U = Var2)
plot_results2 <- as.data.frame(expand.grid(sd, U_star2)) %>% rename(sd = Var1, U = Var2)

e_r1 <-  map2_dfr(plot_results1$sd, plot_results1$U, function(x,y) calc_e_r(x, y, A1))
e_r2 <-  map2_dfr(plot_results2$sd, plot_results2$U, function(x,y) calc_e_r(x, y, A2))

plot_results1 <- cbind(plot_results1, e_r1, e_r2)
colnames(plot_results1) <- c("sd", "U", "e_r1", "e_r2")


ggplot() +
  geom_path(data = capital_lines, aes(y = e_r, x = sigma_r)) +
  geom_path(data = plot_results1, aes(y = e_r1, x = sd), color = "#0f4d92") +
  geom_path(data = plot_results1, aes(y = e_r2, x = sd), color = "#c90016") +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Portfolio"))  +
  ylim(-0.2, 0.5) +
  xlim(0,1.5) +
  ggtitle(bquote("Tangency portfolio given risk aversion," ~ rho ~ "=" ~ .(rho))) +
  annotate(geom="point", x = opt_portfolio1$sigma_r, y = opt_portfolio1$e_r, size = 3) +
  annotate(geom="text", x = opt_portfolio1$sigma_r, y = opt_portfolio1$e_r-.1, size = 3, label = "A = 0.5") +
  annotate(geom="point", x = opt_portfolio2$sigma_r, y = opt_portfolio2$e_r, size = 3)  +
  annotate(geom="text", x = opt_portfolio2$sigma_r, y = opt_portfolio2$e_r+.1, size = 3, label = "A = 2") 
```

---

# Two Risky Assets 


```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}
## Capital Allocation Lines
r_a <- 0.25
r_b <- 0.1
sigma_a <- 0.75
sigma_b <- 0.25
rho <- -.7
A1 <- 0.5
A2 <- 2

w_star1 <- (r_a - r_b) / (A1* (sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) +
  ((sigma_b^2 - rho*sigma_a*sigma_b)/(sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) 
w_star2 <- (r_a - r_b) / (A2* (sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) +
  ((sigma_b^2 - rho*sigma_a*sigma_b)/(sigma_a^2 + sigma_b^2 - 2*rho * sigma_a * sigma_b)) 

opt_portfolio1 <- calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, w_star1)
opt_portfolio2 <- calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, w_star2)
U_star1 <- opt_portfolio1$e_r - (A1/2)*opt_portfolio1$sigma_r^2
U_star2 <- opt_portfolio2$e_r - (A2/2)*opt_portfolio2$sigma_r^2

output <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
capital_lines <- cbind(output, rbind(tibble(w=w))) %>%
  arrange(w)

## Utility Curves
sd <- seq(0,1.5, 0.01)

plot_results1 <- as.data.frame(expand.grid(sd, U_star1)) %>% rename(sd = Var1, U = Var2)
plot_results2 <- as.data.frame(expand.grid(sd, U_star2)) %>% rename(sd = Var1, U = Var2)

e_r1 <-  map2_dfr(plot_results1$sd, plot_results1$U, function(x,y) calc_e_r(x, y, A1))
e_r2 <-  map2_dfr(plot_results2$sd, plot_results2$U, function(x,y) calc_e_r(x, y, A2))

plot_results1 <- cbind(plot_results1, e_r1, e_r2)
colnames(plot_results1) <- c("sd", "U", "e_r1", "e_r2")


ggplot() +
  geom_path(data = capital_lines, aes(y = e_r, x = sigma_r)) +
  geom_path(data = plot_results1, aes(y = e_r1, x = sd), color = "#0f4d92") +
  geom_path(data = plot_results1, aes(y = e_r2, x = sd), color = "#c90016") +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlab(bquote("Standard Deviation of Portfolio"))  +
  ylim(-0.2, 0.5) +
  xlim(0,1.5) +
  ggtitle(bquote("Tangency portfolio given risk aversion," ~ rho ~ "=" ~ .(rho))) +
  annotate(geom="point", x = opt_portfolio1$sigma_r, y = opt_portfolio1$e_r, size = 3) +
  annotate(geom="text", x = opt_portfolio1$sigma_r, y = opt_portfolio1$e_r-.1, size = 3, label = "A = 0.5") +
  annotate(geom="point", x = opt_portfolio2$sigma_r, y = opt_portfolio2$e_r, size = 3)  +
  annotate(geom="text", x = opt_portfolio2$sigma_r, y = opt_portfolio2$e_r+.1, size = 3, label = "A = 2") 
```


---

# The Optimal Risky Portfolio without riskless asset

* Formally, we can derive it using calculus, as
$$
\begin{aligned}
\max_{w_{a}} U(r_{p}) & = E(r_{p}) - \frac{1}{2} A \sigma^{2}(r_{p})\\
\text{s.t.} \; E(r_{p}) &= E(r_{p}) = w_{a}E(r_{a}) + (1-w)E(r_{b})\\
\text{and} \; \sigma^{2}(r_{\text{p}}) &= w_{a}^{2}\sigma^{2}(r_{a}) + (1-w)^{2}\sigma^{2}(r_{b}) + 2w_{a}(1-w_{a})\rho_{a,b}\sigma(r_{a})\sigma(r_{b})
\end{aligned}
$$

* Solving directly (by plugging in and taking derivative w.r.t. $w_{a}$):

$$
\begin{aligned}
w_{a}^{*} &= \frac{E(r_{a}) - E(r_{b})}{A(\sigma_{a}^{2} + \sigma_{b}^{2} - 2\rho_{a,b}\sigma_{a}\sigma_{b})} + \frac{\sigma_{b}^{2} - \rho_{a,b}\sigma_{a}\sigma_{b}}{\sigma_{a}^{2} + \sigma_{b}^{2} - 2\rho_{a,b}\sigma_{a}\sigma_{b}}\\
&=\frac{E(r_{a}) - E(r_{b}) + A \big(\sigma_{b}^{2} - \rho_{a,b}\sigma_{a}\sigma_{b}\big)}{A(\sigma_{a}^{2} + \sigma_{b}^{2} - 2\rho_{a,b}\sigma_{a}\sigma_{b})} 
\end{aligned}
$$

* We can do **better** -- just need a riskless asset

---

# Two risky and one riskless asset

<div id= "left2">
* Add back our riskless asset 
    - $r_{f} = 0.03$
    - $\sigma(r_{f}) = 0$

* What is our Capital Allocation Line when we combine either A or B with our riskless asset?

* To illustrate more clearly the point, let $\sigma(r_{A})=0.5$: 

| Asset | $E(r)$ | $\sigma(r)$ | 
|:-------:|:--------:|:-------------:|
|  A | 0.25 | 0.50 |
| B  | 0.1 | 0.25 |

</div>





---

# Two risky and one riskless asset

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}

r_a <- 0.25
r_b <- 0.1
r_f <- 0.03
sigma_a <- 0.5
sigma_b <- 0.25
sigma_f <- 0
rho <- 0

output1 <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
capital_lines <- cbind(output1, rbind(tibble(w=w))) %>%
  arrange(w)

output_a <-  map_dfr(w, function(x) calc_CAL(r_f, x, (r_a-r_f) /sigma_a, sigma_a ))
output_b <-  map_dfr(w, function(x) calc_CAL(r_f, x, (r_b-r_f) /sigma_b, sigma_b))
capital_lines_no_rf <- capital_lines %>% 
   rename( e_r_norf = e_r) 
 
capital_lines_w_fa <- cbind(output_a, rbind(tibble(w=w))) %>%
  mutate(sigma_fa = w*sigma_a)
capital_lines_w_fb <- cbind(output_b, rbind(tibble(w=w))) %>%
  mutate(sigma_fb = w*sigma_b)

 
ggplot() +
  geom_path(data = capital_lines_no_rf, aes(y = e_r_norf, x = sigma_r)) +
  geom_path(data = capital_lines_w_fa, aes(y = e_r, x = sigma_fa), color = "#0f4d92") +
  geom_path(data = capital_lines_w_fb, aes(y = e_r, x = sigma_fb), color = "#c90016") +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .8) +
  ylim(0, .3) +
  annotate(geom="point", x = sigma_a, y = r_a, size=3) +
  annotate(geom="point", x = sigma_b, y = r_b, size=3) +
  annotate(geom="text", x = sigma_a, y = r_a-.03, size=3, label = "A") +
  annotate(geom="text", x = sigma_b, y = r_b-.03, size=3, label = "B") +
  xlab(bquote("Standard Deviation"))  +
  ggtitle(bquote("Tangency portfolio given risk aversion," ~ rho ~ "=" ~ .(rho)))  
```

<div id = "left">
* The capital allocation line generated by asset A and the risk free asset dominates that of asset B!
    - Why?
</div>

---


# Two risky and one riskless asset

```{r,  out.width='1600px' , fig.asp = .4,  message=FALSE, warning=FALSE}

r_a <- 0.25
r_b <- 0.1
r_f <- 0.03
sigma_a <- 0.5
sigma_b <- 0.25
sigma_f <- 0
rho <- 0

output1 <-  map_dfr(w, function(x) calc_CAL_ab(r_a, r_b, sigma_a, sigma_b, rho, x))
               
capital_lines <- cbind(output1, rbind(tibble(w=w))) %>%
  arrange(w)

output_a <-  map_dfr(w, function(x) calc_CAL(r_f, x, (r_a-r_f) /sigma_a, sigma_a ))
output_b <-  map_dfr(w, function(x) calc_CAL(r_f, x, (r_b-r_f) /sigma_b, sigma_b))
capital_lines_no_rf <- capital_lines %>% 
   rename( e_r_norf = e_r) 
 
capital_lines_w_fa <- cbind(output_a, rbind(tibble(w=w))) %>%
  mutate(sigma_fa = w*sigma_a)
capital_lines_w_fb <- cbind(output_b, rbind(tibble(w=w))) %>%
  mutate(sigma_fb = w*sigma_b)

 
ggplot() +
  geom_path(data = capital_lines_no_rf, aes(y = e_r_norf, x = sigma_r)) +
  geom_path(data = capital_lines_w_fa, aes(y = e_r, x = sigma_fa), color = "#0f4d92") +
  geom_path(data = capital_lines_w_fb, aes(y = e_r, x = sigma_fb), color = "#c90016") +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .8) +
  ylim(0, .3) +
  annotate(geom="point", x = sigma_a, y = r_a, size=3) +
  annotate(geom="point", x = sigma_b, y = r_b, size=3) +
  annotate(geom="text", x = sigma_a, y = r_a-.03, size=3, label = "A") +
  annotate(geom="text", x = sigma_b, y = r_b-.03, size=3, label = "B") +
  xlab(bquote("Standard Deviation"))  +
  ggtitle(bquote("Tangency portfolio given risk aversion," ~ rho ~ "=" ~ .(rho)))  
```

* We can pick a *different* combination of assets A and B from the frontier and combine it with our riskless asset. 

* This "tangency portfolio" is the **mean-variance efficient (MVE) portfolio.**

---

# Finding the Efficient Risky Portfolio

* Note that the tangency portfolio can be defined as the portfolio on the frontier that has the highest Sharpe Ratio (reward to risk ratio)

$$
SR = \frac{E(r_{p} - r_{f})}{\sigma_{p}}
$$

* Subject to being on the portfolio frontier!

$$
\begin{aligned}
\max_{w_{a}} & \frac{E(r_{p} - r_{f})}{\sigma_{p}}\\
\text{s.t.} \; & E(r_{p}) = w_{a}E(r_{a}) + (1-w_{a})E(r_{b})\\
\text{and} \; & \sigma_{p}^{2} = w_{a}^{2}\sigma^{2}(r_{a}) + (1-w)^{2}\sigma^{2}(r_{b}) + 2w_{a}(1-w_{a})\rho_{a,b}\sigma(r_{a})\sigma(r_{b})
\end{aligned}
$$

---

# Finding the MVE Portfolio

* The solution for $w_{a,MVE}$ is:


$$
w_{a,MVE}^{*} = \frac{E(r_{a} - r_{f})\sigma^{2}_{b}- E(r_{b} - r_{f})\sigma_{a}\sigma_{b}\rho_{a,b}}{E(r_{a}-r_{f})\sigma_{b}^{2} + E(r_{b}-r_{f})\sigma_{a}^{2} - \big[E(r_{a}-r_{f}) + E(r_{b}-r_{f})\big]\sigma_{a}\sigma_{b}\rho_{a,b}}
$$

* Key thing to notice -- this optimal portfolio does not include anything related to investor risk aversion ($A$)

* **Takeaway**: All investors do best by choosing the same risky portfolio and *then* deciding how much to allocate to the riskless asset based on individual preferences

---

# Mean-Variance Cookbook

Now we have a simple two step recipe for an optimal portfolio, based on our taste for risk!

1. Specify the expected returns, standard deviations and covariance between our risky assets. Also define the riskless rate of return.
    - using these parameters, solve for the unique MVE portfolio. This is the tangency portfolio! Everyone wants this risky portfolio, regardless of taste for risk.
2. Choose weights between the MVE portfolio and the riskless asset based on your taste for risk $A$. 

* Note: this statement holds for as many risky assets as we would like!

---

# Many ($N$) risky assets 

* Let's do an example with the following stocks: Ford, IBM, Microsoft, Netflix and Walmart.

* Take their monthly returns from 2010-2018. What's their average monthly return and standard deviation? What about the Sharpe Ratio?
```{r, out.width='1600px' ,warning = FALSE, message = FALSE}
library(tidyquant)
library(ggrepel)
# step 1: construct vector of expected returns, and their variance-covariance matrix
# step 2: plot different stocks in sd expected return space
# step 3: calculate mean-variance efficient portfolio equal to
#         highest return under consideration
# step 4 calculate the tangency portfolio

# step 3: plot frontier


efficient.portfolio <- function(er, cov.mat, target.return)
  {
  asset.names <- names(er)
  er <- as.vector(er) # assign names if none exist
  N <- length(er)
  cov.mat <- as.matrix(cov.mat)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")
  
  ones <- rep(1, N)
  top <- cbind(2*cov.mat, er, ones)
  bot <- cbind(rbind(er, ones), matrix(0,2,2))
  A <- rbind(top, bot)
  b.target <- as.matrix(c(rep(0, N), target.return, 1))
  x <- solve(A, b.target)
  w <- x[1:N]
  
  names(w) <- asset.names
  er.port <- crossprod(er,w)
  sd.port <- sqrt(w %*% cov.mat %*% w)
  ans <- list("call" = call,
	      "er" = as.vector(er.port),
	      "sd" = as.vector(sd.port),
	      "weights" = w) 
  return(ans)
}  

tangency.portfolio <- function(er,cov.mat,risk.free, shorts=TRUE)
{
  asset.names <- names(er)
  if(risk.free < 0)
    stop("Risk-free rate must be positive")
  er <- as.vector(er)
  cov.mat <- as.matrix(cov.mat)
  N <- length(er)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")
  cov.mat.inv <- solve(cov.mat)
  w.t <- cov.mat.inv %*% (er - risk.free) # tangency portfolio
  w.t <- as.vector(w.t/sum(w.t))          # normalize weights
  names(w.t) <- asset.names
  er.t <- crossprod(w.t,er)
  sd.t <- sqrt(t(w.t) %*% cov.mat %*% w.t)
  tan.port <- list("call" = call,
		   "er" = as.vector(er.t),
		   "sd" = as.vector(sd.t),
		   "weights" = w.t)
  return(tan.port)  
}


efficient.frontier <- function(er, cov.mat, port1, port2, nport=20, alpha.min=-0.5, alpha.max=1.5)
{
  #
  # check for valid inputs
  #
  asset.names <- names(er)
  er <- as.vector(er)
  N <- length(er)
  cov.mat <- as.matrix(cov.mat)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")

  #
  # create portfolio names
  #
  port.names <- rep("port",nport)
  ns <- seq(1,nport)
  port.names <- paste(port.names,ns)

  
  # compute efficient frontier as convex combinations of two efficient portfolios

  w.max <- port1$weights    
  w.min <- port2$weights
  a <- seq(from=alpha.min,to=alpha.max,length=nport) # convex combinations
  we.mat <- a %o% w.min+ (1-a) %o% w.max	         # rows are efficient portfolios
  er.e <- we.mat %*% er							                 # expected returns of efficient portfolios
  er.e <- as.vector(er.e)
  
  names(er.e) <- port.names
  cov.e <- we.mat %*% cov.mat %*% t(we.mat) # cov mat of efficient portfolios
  sd.e <- sqrt(diag(cov.e))					        # std devs of efficient portfolios
  sd.e <- as.vector(sd.e)
  names(sd.e) <- port.names
  dimnames(we.mat) <- list(port.names,asset.names)

  # 
  # summarize results
  #
  ans <- list("call" = call,
	      "er" = er.e,
	      "sd" = sd.e,
	      "weights" = we.mat)
  class(ans) <- "Markowitz"
  ans
}

stock_returns <- read_csv("~/Dropbox/Teaching/MGT544Spring2019/Class Lectures/Data/stock_returns.csv", 
                          col_types = cols(date = col_date(format = "%m/%d/%Y")))

stock_returns <- stock_returns %>% 
  group_by(TICKER, date) %>%
  mutate(test = RET+1) %>%
  mutate(annual_ret = (RET+1)^12 -1) %>% 
  filter(year(date) > 2009) %>%
  filter(TICKER != "WMT")
  
expected_returns <- stock_returns %>% group_by(TICKER) %>%
  summarize(return = round(mean(RET), digits = 3), 
            sd = round(sd(RET), digits = 3), 
            sharpe = round(mean(RET)/ sd(RET), digits = 3))

options("kableExtra.html.bsTable" = T)
kable(
  head(expected_returns, 10), booktabs = TRUE,
  col.names = c("Ticker", 
                "Monthly Return",
                "Monthly SD",
                "Sharpe Ratio"),
  caption = 'Historical Returns for 4 stocks (2010-2018)'
) %>%
  kable_styling(bootstrap_options = c("striped", "condensed")) 


covariance <- stock_returns %>%
  ungroup() %>%
  select(TICKER, date, RET) %>%
  spread(TICKER, RET) %>% select(-date)

correlations <- cor(as.matrix(covariance))
cov.mat <- cov(as.matrix(covariance))

er <- expected_returns$return
names(er) <- expected_returns$TICKER

e.port.ntflx <- efficient.portfolio(er, cov.mat, max(er))
tan.port <- tangency.portfolio(er, cov.mat, 0.0024)
ef <- efficient.frontier(er, cov.mat, e.port.ntflx, tan.port, alpha.min=-100, alpha.max=100, nport=1000)


```




---

# Many Risky Assets

```{r, out.width='1600px' , fig.asp = .5, message = FALSE, warning=FALSE}
ggplot() +
  geom_point(data = expected_returns, aes(y = return, x = sd, color = TICKER)) +
  geom_text_repel(data = expected_returns, aes(y = return, x = sd, color = TICKER, label = TICKER)) +
  annotate(geom = "point", x = 0, y = 0.0024) +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .2) +
  xlab("Standard deviation of portfolio") +
  scale_color_viridis_d(guide = FALSE) +
  ylim(0, .06)
```

---

# Many Risky Assets

```{r, out.width='1600px' , fig.asp = .5, message = FALSE, warning=FALSE}

tan_line <- tibble(sd = c(0, tan.port$sd, 1.4*tan.port$sd), er = c(0.0024, tan.port$er, ((tan.port$er - 0.0024) / tan.port$sd)*1.4*tan.port$sd + 0.0024))
ggplot() +
  geom_point(data = expected_returns, aes(y = return, x = sd, color = TICKER)) +
  geom_text_repel(data = expected_returns, aes(y = return, x = sd, color = TICKER, label = TICKER)) +
  geom_path(data = tan_line, aes(y = er, x = sd), color = "#0f4d92") +
  annotate(geom = "point", x = e.port.ntflx$sd, y = e.port.ntflx$er) +
  annotate(geom = "point", x = tan.port$sd, y = tan.port$er) +
  annotate(geom = "point", x = 0, y = 0.0024) +
  theme_minimal() +  ylab("") +
  xlab("Standard deviation of portfolio") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .2) +
  scale_color_viridis_d(guide = FALSE) +
  ylim(0, .06)
```


---

# Many Risky Assets


```{r, out.width='1600px' , fig.asp = .5, message = FALSE, warning=FALSE}

ggplot() +
  geom_point(data = expected_returns, aes(y = return, x = sd, color = TICKER)) +
  geom_text_repel(data = expected_returns, aes(y = return, x = sd, color = TICKER, label = TICKER)) +
  geom_path(data = tan_line, aes(y = er, x = sd), color = "#0f4d92") +
  geom_path(aes(y = ef$er, x = ef$sd)) +
  annotate(geom = "point", x = e.port.ntflx$sd, y = e.port.ntflx$er) +
  annotate(geom = "point", x = tan.port$sd, y = tan.port$er) +
  annotate(geom = "point", x = 0, y = 0.0024) +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .2) +
  xlab("Standard deviation of portfolio") +
  scale_color_viridis_d(guide = FALSE) +
  ylim(0, .06)
```


---

# Many Risky Assets (adding assets helps diversify)


```{r, message=FALSE}
stock_returns2 <- read_csv("~/Dropbox/Teaching/MGT544Spring2019/Class Lectures/Data/stock_returns.csv", 
                          col_types = cols(date = col_date(format = "%m/%d/%Y")))

stock_returns2 <- stock_returns2 %>% 
  group_by(TICKER, date) %>%
  mutate(test = RET+1) %>%
  mutate(annual_ret = (RET+1)^12 -1) %>% 
  filter(year(date) > 2009) 
  
expected_returns2 <- stock_returns2 %>% group_by(TICKER) %>%
  summarize(return = round(mean(RET), digits = 3), 
            sd = round(sd(RET), digits = 3), 
            sharpe = round(mean(RET)/ sd(RET), digits = 3))


covariance <- stock_returns2 %>%
  ungroup() %>%
  select(TICKER, date, RET) %>%
  spread(TICKER, RET) %>% select(-date)

correlations <- cor(as.matrix(covariance))
cov.mat2 <- cov(as.matrix(covariance))

er2 <- expected_returns2$return
names(er2) <- expected_returns2$TICKER

e.port.ntflx2 <- efficient.portfolio(er2, cov.mat2, max(er2))
tan.port2 <- tangency.portfolio(er2, cov.mat2, 0.0024)
ef2 <- efficient.frontier(er2, cov.mat2, e.port.ntflx2, tan.port2, alpha.min=-100, alpha.max=100, nport=1000)
```

```{r, out.width='1600px' , fig.asp = .5, message = FALSE, warning=FALSE}
tan_line2 <- tibble(sd = c(0, tan.port2$sd, 1.4*tan.port2$sd), er = c(0.0024, tan.port2$er, ((tan.port2$er - 0.0024) / tan.port2$sd)*1.4*tan.port2$sd + 0.0024))

ggplot() +
  geom_point(data = expected_returns2, aes(y = return, x = sd, color = TICKER)) +
  geom_text_repel(data = expected_returns2, aes(y = return, x = sd, color = TICKER, label = TICKER)) +
  geom_path(aes(y = ef$er, x = ef$sd)) +
  geom_path(aes(y = ef2$er, x = ef2$sd)) +
  theme_minimal() +  ylab("") +
  xlab("Standard deviation of portfolio") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .2) +
  scale_color_viridis_d(guide = FALSE) +
  ylim(0, .06)
```

So why does diversification shift the frontier?

---

# Diversification benefits

So why does diversification shift the frontier?

* Adding assets can never make us worse off (if they did, we would put zero weight in them)
* Can only help reduce risk via imperfect or negative correlation
* In spite of being risk averse, we’d like to get exposure to as many different types of risks as possible
* This helps minimize our exposure to any given one (e.g. putting our eggs in as many different baskets as possible)

```{r}

options("kableExtra.html.bsTable" = T)
kable(
  head(as.tibble(cor(as.matrix(covariance))), 10), booktabs = TRUE,
  caption = 'Covariance of Returns for 5 stocks (2010-2018)'
) %>%
  kable_styling(bootstrap_options = c("striped", "condensed")) 


```

---


# In practice, how do we construct a frontier?

* The mutual fund separation theorem says the entire “bullet” can be constructed by any two efficient portfolios on the bullet
    - Tangency or MVE portfolio
        * Found by maximizing the Sharpe Ratio
    - Minimum Variance Portfolio (MVP)
        * Find by minimizing the standard deviation
* With no constraints, can solve exactly with calculus (or solver)
    - With constraints, need to use numerical solver
    
* Then, with these two portfolios, just vary the weights on each (as in our two risky asset setting)

---

# Finding the Minimum Variance Portfolio

* Instead of maximizing the Sharpe ratio, what if we want to minimize risk ignoring returns?
    * Obviously, if we have the riskless asset, we invest exclusively in that. 
    * What about just in the risky assets?
    
* In two asset case, problem is defined as:

$$
\begin{aligned}
\min_{w_{a}} \sigma^{2}_{p} &=  w_{a}^{2}\sigma^{2}(r_{a}) + (1-w_{a})^{2}\sigma^{2}(r_{b}) + 2w_{a}(1-w_{a})\rho_{a,b}\sigma(r_{a})\sigma(r_{b})\\
w_{a, MVP}^{*} &= \frac{\sigma_{b}^{2} - \sigma_{a}\sigma_{b}\rho_{a,b}}{\sigma_{a}^{2} + \sigma_{b}^{2} - 2\sigma_{a}\sigma_{b}\rho_{a,b}}
\end{aligned}
$$

* For N assets, the problem is defined using vectors (optional):

$$
\begin{aligned}
\min_{\mathbf{w}} \sigma^{2}_{p} &=  \mathbf{w}' \Sigma \mathbf{w}\\
\text{s.t.} \; \mathbf{w}'\mathbf{1} &= 1\\
\end{aligned}
$$

---

# Parameter Uncertainty

* So far, portfolio optimization looks easy
* But, we have assumed we know the right inputs to plug into our model
* In practice what are the expected returns?
* Similar, but less severe issues arise with covariances
* See Garlappi, Demiguel, Uppal 2007 RFS (on course website)

---

# Parameter uncertainty -- an extreme example

* Suppose two assets have expected returns of 8%,and standard deviations of 20% and a correlation of 0.99.
* What is the optimal portfolio? 

<div class="fragment" data-fragment-index="1">
* 50/50 by symmetry
* Now suppose we get more data, and realizxe that one asset has an expected return of 9%
* Our new weights would be 635 and -535
* Small errors can have extreme effects!
</div>

---

# How do we deal with this?

* Models
    - CAPM/APT serve as models of expected returns and give us theoretical guidence on parameter inputs
* Constraints
    - Extreme mistakes in parameters will generate extreme portfolios
    - Constraining weights can minimize this risk
* Bayesian analysis
    - Supplement data with prior beliefs about the model inputs
    - Model-based, or just naive
* Machine-learning
    - Improve our predictions
    - Minimize our mean-squared error of our parameters
    
---

# Bayesian Methods

* What are Bayesian methods? 
* Suppose I have two signals ($s_{1}$ and $s_{2}$) about a parameter value, $\mu$
* Each signal is distributed normally, with a mean of $\mu$ and a variance of $\sigma_{i}^{2}$
- The "best" forecast of the parameter $\mu$ is a precision-weighted average of $s_{1}$ and $s_{2}$:

$$
\begin{aligned}
\hat{\mu} &= \frac{s_{1}\sigma_{2}^{2} + s_{2}\sigma_{1}^{2}}{\sigma_{2}^{2} + \sigma_{1}^{2}}\\
&= \frac{\frac{1}{\sigma_{1}^{2}} s_{1} + \frac{1}{\sigma_{2}^{2}}s_{2}}{\frac{1}{\sigma_{1}^{2}} + \frac{1}{\sigma_{2}^{2}}}\\
\end{aligned}
$$

---

# Bayesian Methods

* Suppose we take historical returns as informative about the future
    - but we don't want to overweight them because they're imprecise
* Use your prior beliefs (either your own personal feelings, or from other sources) as your second signal, and weight based on precision
    - For example, expected returns estimates might be a blended average of historical averages and constant returns
    - Historical record weighted based on precision
    - Often called parameter "shrinkage"
    
---

# Bayesian Methods

* Optimal Bayesian weighting can be shown to shrink historical returns towards the minimum-variance portfolio (the tip of the bullet)

$$
\begin{aligned}
\hat{\mu}_{JS} &=  (1- \hat{w})\bar{X} + \hat{w} \mu \mathbf{1}\\
\mu &= \frac{\mathbf{1}'\Sigma^{-1}\bar{X}}{\mathbf{1}'\Sigma^{-1}\mathbf{1}}\\
\hat{w} &= \frac{N+2}{(N+2) + (X - \mu\mathbf{1})'T\Sigma^{-1}(X - \mu\mathbf{1})}
\end{aligned}
$$

* where $X$ is our empirically observed average returns and $\mu$ is the return of the MVP
    - $\mu$ is not explicitly designed to be the MVP return, but it happens to be the portfolio which minimizes variance
    - N is the number of stocks, T is the number of time periods and $\Sigma$ is  the covariance matrix (estimated too)

* What's the intuition?

---

# Bayesian Methods

* Taken to an extreme, this gives us some naive portfolios

* For example, what happens if I put all my weight on the MVP prior (e.g. returns are flat across all stocks)
    - What portfolio do you think I'll get?
    - Why would I put all my weight on the simple prior?
    
* Note the MVP (a "naive" portfolio) can be motivated by Bayesian methods

---

# Bayesian Methods

* Of course, just like means, covariance matrix can be shrunk as well
    - What portfolio do you get from extreme shrinkage of expected returns and covariances?
    
* Meanwhile, can show that weight constraints are equivalent to shrinking the covariance matrix for the assets affected by constraints
    - Jaganathan and Ma "Risk Reduction in Large Portfolios", Journal of Finance
    
---

# Constraints

* What if we constrain our portfolio weights?

* Simple example: only long positions (to minimize losses)

```{r, warning=FALSE, message=FALSE}

globalMin.portfolio <- function(er, cov.mat, shorts=TRUE)
{

  
  #
  # check for valid inputs
  #
  asset.names <- names(er)
  er <- as.vector(er) # assign names if none exist
  cov.mat <- as.matrix(cov.mat)
  N <- length(er)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")
  # remark: could use generalized inverse if cov.mat is positive semi-definite

  #
  # compute global minimum portfolio
  #
  if(shorts==TRUE){
    cov.mat.inv <- solve(cov.mat)
    one.vec <- rep(1,N)
    w.gmin <- rowSums(cov.mat.inv) / sum(cov.mat.inv)
    w.gmin <- as.vector(w.gmin)
  } else if(shorts==FALSE){
    Dmat <- 2*cov.mat
    dvec <- rep.int(0, N)
    Amat <- cbind(rep(1,N), diag(1,N))
    bvec <- c(1, rep(0,N))
    result <- quadprog::solve.QP(Dmat=Dmat,dvec=dvec,Amat=Amat,bvec=bvec,meq=1)
    w.gmin <- round(result$solution, 6)
  } else {
    stop("shorts needs to be logical. For no-shorts, shorts=FALSE.")
  }
 
  names(w.gmin) <- asset.names
  er.gmin <- crossprod(w.gmin,er)
  sd.gmin <- sqrt(t(w.gmin) %*% cov.mat %*% w.gmin)
  gmin.port <- list("call" = call,
		    "er" = as.vector(er.gmin),
		    "sd" = as.vector(sd.gmin),
		    "weights" = w.gmin)
  class(gmin.port) <- "portfolio"
  gmin.port
}


efficient.portfolio <- function(er, cov.mat, target.return, shorts=TRUE)
{


  #
  # check for valid inputs
  #
  asset.names <- names(er)
  er <- as.vector(er) # assign names if none exist
  N <- length(er)
  cov.mat <- as.matrix(cov.mat)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")
  # remark: could use generalized inverse if cov.mat is positive semidefinite

  #
  # compute efficient portfolio
  #
  if(shorts==TRUE){
    ones <- rep(1, N)
    top <- cbind(2*cov.mat, er, ones)
    bot <- cbind(rbind(er, ones), matrix(0,2,2))
    A <- rbind(top, bot)
    b.target <- as.matrix(c(rep(0, N), target.return, 1))
    x <- solve(A, b.target)
    w <- x[1:N]
  } else if(shorts==FALSE){
    Dmat <- 2*cov.mat
    dvec <- rep.int(0, N)
    Amat <- cbind(rep(1,N), er, diag(1,N))
    bvec <- c(1, target.return, rep(0,N))
    result <- quadprog::solve.QP(Dmat=Dmat,dvec=dvec,Amat=Amat,bvec=bvec,meq=2)
    w <- round(result$solution, 6)
  } else {
    stop("shorts needs to be logical. For no-shorts, shorts=FALSE.")
  }

  #
  # compute portfolio expected returns and variance
  #
  names(w) <- asset.names
  er.port <- crossprod(er,w)
  sd.port <- sqrt(w %*% cov.mat %*% w)
  ans <- list("call" = call,
	      "er" = as.vector(er.port),
	      "sd" = as.vector(sd.port),
	      "weights" = w) 
  class(ans) <- "portfolio"
  return(ans)
}

efficient.frontier <- function(er, cov.mat, nport=20, alpha.min=-0.5, alpha.max=1.5, shorts=TRUE)
{
  
  #
  # check for valid inputs
  #
  asset.names <- names(er)
  er <- as.vector(er)
  N <- length(er)
  cov.mat <- as.matrix(cov.mat)
  if(N != nrow(cov.mat))
    stop("invalid inputs")
  if(any(diag(chol(cov.mat)) <= 0))
    stop("Covariance matrix not positive definite")

  #
  # create portfolio names
  #
  port.names <- rep("port",nport)
  ns <- seq(1,nport)
  port.names <- paste(port.names,ns)

  #
  # compute global minimum variance portfolio
  #
  cov.mat.inv <- solve(cov.mat)
  one.vec <- rep(1, N)
  port.gmin <- globalMin.portfolio(er, cov.mat, shorts)
  w.gmin <- port.gmin$weights

  if(shorts==TRUE){
    # compute efficient frontier as convex combinations of two efficient portfolios
    # 1st efficient port: global min var portfolio
    # 2nd efficient port: min var port with ER = max of ER for all assets
    er.max <- max(er)
    port.max <- efficient.portfolio(er,cov.mat,er.max)
    w.max <- port.max$weights    
    a <- seq(from=alpha.min,to=alpha.max,length=nport) # convex combinations
    we.mat <- a %o% w.gmin + (1-a) %o% w.max	         # rows are efficient portfolios
    er.e <- we.mat %*% er							                 # expected returns of efficient portfolios
    er.e <- as.vector(er.e)
  } else if(shorts==FALSE){
    we.mat <- matrix(0, nrow=nport, ncol=N)
    we.mat[1,] <- w.gmin
    we.mat[nport, which.max(er)] <- 1
    er.e <- as.vector(seq(from=port.gmin$er, to=max(er), length=nport))
    for(i in 2:(nport-1)) 
      we.mat[i,] <- efficient.portfolio(er, cov.mat, er.e[i], shorts)$weights
  } else {
    stop("shorts needs to be logical. For no-shorts, shorts=FALSE.")
  }
  
  names(er.e) <- port.names
  cov.e <- we.mat %*% cov.mat %*% t(we.mat) # cov mat of efficient portfolios
  sd.e <- sqrt(diag(cov.e))					        # std devs of efficient portfolios
  sd.e <- as.vector(sd.e)
  names(sd.e) <- port.names
  dimnames(we.mat) <- list(port.names,asset.names)

  # 
  # summarize results
  #
  ans <- list("call" = call,
	      "er" = er.e,
	      "sd" = sd.e,
	      "weights" = we.mat)
  class(ans) <- "Markowitz"
  ans
}

ef <-efficient.frontier(er2, cov.mat2, 20, -0.5, 1.5, shorts=FALSE)

```


```{r, out.width='1600px' , fig.asp = .5, message = FALSE, warning=FALSE}
tan_line2 <- tibble(sd = c(0, tan.port2$sd, 1.5*tan.port2$sd), er = c(0.0024, tan.port2$er, tan.port2$er*1.5 - 0.0024))

ggplot() +
  geom_point(data = expected_returns2, aes(y = return, x = sd, color = TICKER)) +
  geom_text_repel(data = expected_returns2, aes(y = return, x = sd, color = TICKER, label = TICKER)) +
  geom_path(aes(y = ef$er, x = ef$sd), color =  "#0f4d92") +
  geom_path(aes(y = ef2$er, x = ef2$sd)) +
  theme_minimal() +  ylab("") +
  theme(text = element_text(size=18, 
                            family="News Cycle"))  +
  xlim(0, .2) +
  xlab("Standard deviation of portfolio") +
  scale_color_viridis_d(guide = FALSE) +
  ylim(0, .06)
```



---

# Constraints

* When considering constraints, think about what underlying fundamentals are implied by the constraints 
* i.e. "what expected returns would I have to assume to make a constrained portfolio also be the optimal unconstrained portfolio?"
* Next, we learn how to invert the portfolio choice process, turning chosen weights into implied expected returns

---

# Conclusions

* Mean-variance analysis works off the assumption that all investors care about is the mean and variance of returns

* This delivers some powerful takeaways
    - Portfolio management can be broken down into two steps:
        1. Find the unique mean-variance efficient portfolio
        2. Combine this with the riskless asset to suit preferences for risk

* What's wrong with this?
    - Not much! There is a lot of agreement with these points.
    - However, **measuring** the inputs is really hard! Garbage in, garbage out
    - Need to have models of expected returns!
    



